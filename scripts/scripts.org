* Utils
** Architecture
   #+begin_src shell :shebang #!/bin/bash :noweb yes :results output :tangle ../bash/.bashrc.d/scripts.bash
<<Docker>>
<<language>>
<<programming>>
<<tangle_scripts>>
sha512sum -c ~/dotfiles/bash/.bashrc.d/scripts_checksum >&/dev/null
if [ $? -eq 1 ]; then
    tangle_scripts
    echo -e "\n\n\nTangling done\n\n\n"
    source ~/.bashrc
fi
   #+end_src
** Programming
*** test && commit || revert (TCR)
    #+NAME: TCR
    #+begin_src shell :noweb yes :exports code
tcr_loop() {
    test_command="$@"

    if ! isWorkDirClean; then
        echo "Please make sure you have a clean working directory before starting the TCR loop"
        echo "Commit changes and come back for some fun!"
        return 1
    fi

    if ! ${test_command}; then
        echo
        echo "Please make sure the test command passes before starting the TCR loop"
        echo "Maybe test a smaller subcase more relevant to the files you are going to work on?"
        return 1
    fi
    inotify-hookable --ignore-paths $(pwd)/.git/ $(pwd)/build/ --watch-directories $(pwd) --quiet -c "tcr ${test_command}"
}
    #+end_src

    #+begin_src shell :shebang #!/bin/bash :noweb yes :results output :tangle tcr
isWorkDirClean(){
    if [ -z "$(git status --porcelain)" ]; then
        return 0
    fi
    return 1
}

isRebaseInProcess() {
    test -d "$(git rev-parse --git-path rebase-merge)" || test -d "$(git rev-parse --git-path rebase-apply) 2>/dev/null"
}

git-WIP () {
    git add --all
    git commit -m "WIP"
}

test_command="$@"

if ! isWorkDirClean && ! isRebaseInProcess; then
    $test_command && git-WIP || git reset --hard
fi
   #+end_src
*** Architecture
   #+NAME: programming
   #+begin_src shell :noweb yes :exports code
<<grepcpp>>
<<greper>>
<<generateclangcomplete>>
<<timestamp>>
<<git>>
<<jokes>>
<<fix_protocol>>
<<TCR>>
   #+end_src

*** C++ stuff

 #+NAME: generateclangcomplete
 #+begin_src shell :noweb yes :exports code
generateclangcomplete () {
    GIT_ROOT=$(git rev-parse --show-toplevel)
    echo "Removing"${GIT_ROOT}/build/
    rm -rf ${GIT_ROOT}/build/
    mkdir ${GIT_ROOT}/build/
    cd ${GIT_ROOT}/build
    clangcompletepp
    cd -
}
 #+end_src
*** Grepping away!

   #+NAME: grepcpp
   #+begin_src shell :noweb yes :exports code
grepcpp () {
    grep -IRsnEi --exclude-dir=build --include="*.h" --include="*.cpp" --include="*.hpp" "${@}"
}
   #+end_src

   #+NAME: greper
   #+begin_src shell :noweb yes :exports code
greper () {
    grep -IRsnEi --exclude-dir=env --exclude-dir=build --exclude="*.bash_history" "${@}"
}
   #+end_src
*** Timestamping
    #+NAME: timestamp
    #+begin_src shell :noweb yes :exports code
timestamp () {
    date +"%Y-%m-%d_%H:%M:%S.%N"
}
    #+end_src
*** Fix protocol
    #+NAME: fix_protocol
    #+begin_src shell :noweb yes :exports code
<<findFIXfield>>
<<findMeaningOfValueOfFIXfield>>
    #+end_src
**** Find FIX field
     #+NAME: findFIXfield
     #+begin_src shell :noweb yes :exports code
findFIXfield_in_Docker () {
    VTFIXDataDictionary=/data/programs/vtcommon-files/dictionary/VTFIXDataDictionary.xml
    FixValues=/usr/local/quickfix-1.13.3.VT13/include/quickfix/FixValues.h
    VTFixFieldNumbers=/data/programs/vtcommon/include/vtfix-base/9.5.8/VTFixFieldNumbers.h
    VTFixFields=/data/programs/vtcommon/include/vtfix-base/9.5.8/VTFixFields.h
    query_input=$1

    grep -vh required $VTFIXDataDictionary $FixValues $VTFixFieldNumbers $VTFixFields | grep -Phi "field\s(number|name)=\".*?${query_input}.*?\""
}

findFIXfield () {
    amIinDocker >/dev/null
    rc=$?
    if [[ $rc != 0 ]]; then
        docker-compose -f ~/docker-services/dev/docker-compose.yml exec dev_rhel7 bash -c "source ~/.bashrc.d/scripts.bash >/dev/null && findFIXfield_in_Docker $1" 2>/dev/null | grep -Pi "field.*$1.*?\""
    else
        findFIXfield_in_Docker "$1"
    fi
}
     #+end_src


**** Find value of field
     #+NAME: findMeaningOfValueOfFIXfield
     #+begin_src shell :noweb yes :exports code
findMeaningOfValueOfFIXfield_in_Docker () {
    VTFIXDataDictionary=/data/programs/vtcommon-files/dictionary/VTFIXDataDictionary.xml
    FixValues=/usr/local/quickfix-1.13.3.VT13/include/quickfix/FixValues.h
    VTFixFieldNumbers=/data/programs/vtcommon/include/vtfix-base/9.5.8/VTFixFieldNumbers.h
    VTFixFields=/data/programs/vtcommon/include/vtfix-base/9.5.8/VTFixFields.h

    if [ "$#" == 2 ]; then
        VALUE="$2"
    else
        VALUE=
    fi
    FIELD_NAME=$1
    grep -Phi  "const.*${FIELD_NAME}.*${VALUE}.*;" $VTFIXDataDictionary $FixValues $VTFixFieldNumbers $VTFixFields
}

findMeaningOfValueOfFIXfield () {
    amIinDocker >/dev/null
    rc=$?
    if [[ $rc != 0 ]]; then
        docker-compose -f ~/docker-services/dev/docker-compose.yml exec dev_rhel7 bash -c "source ~/.bashrc.d/scripts.bash >/dev/null && findMeaningOfValueOfFIXfield_in_Docker $1 $2" 2>/dev/null | grep "const.*;"
    else
        findMeaningOfValueOfFIXfield_in_Docker "$1" "$2"
    fi
}
#+end_src

*** Git

    #+NAME: git
    #+begin_src shell :noweb yes :exports code
<<lazygit>>
<<areTherePirateVersions>>
<<isWorkDirClean>>
<<isRebaseInProcess>>
<<git-WIP>>
    #+end_src


**** Git hooks

     #+NAME: areTherePirateVersions
     #+begin_src shell :noweb yes :exports code
areTherePirateVersions() {
    if [ "$(git tag | grep pirate | wc -l)" == 0 ]; then
        return 0
    else
        return 1
    fi
}
     #+end_src
***** pre-push


  #+begin_src shell :shebang #!/bin/bash :results output :tangle git-hooks/pre-push
#!/usr/bin/env bash

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
	if [ "$local_sha" = $z40 ]
	then
		# Handle delete
		:
	else
		if [ "$remote_sha" = $z40 ]
		then
			# New branch, examine all commits
			range="$local_sha"
		else
			# Update to existing branch, examine new commits
			range="$remote_sha..$local_sha"
		fi

		# Check for WIP commit
		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
		if [ -n "$commit" ]
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

source ~/.bashrc # this does nothing, sourcing directly scripts.bash is needed. Weird.
source ~/.bashrc.d/scripts.bash

areTherePirateVersions
rc=$?
if [[ $rc != 0 ]]; then
    echo "Cannot push, pirate version" $(git tag | grep pirate) "found"
else
    echo "No pirate versions. You can push"
fi

exit $rc
  #+end_src
**** Lazygit

     #+NAME: lazygit
     #+begin_src shell :noweb yes :exports code
lazygit() {
    cd ~/Exocortex
    git add .
    git commit -m "`date`"
    git push
    cd -
}
     #+end_src
**** CleanDir
     #+NAME: isWorkDirClean
     #+begin_src shell :noweb yes :exports code
isWorkDirClean(){
    if [ -z "$(git status --porcelain)" ]; then
        return 0
    fi
    return 1
}
     #+end_src

**** Rebase in process
     #+NAME: isRebaseInProcess
     #+begin_src shell :noweb yes :exports code
isRebaseInProcess() {
    test -d "$(git rev-parse --git-path rebase-merge)" || test -d "$(git rev-parse --git-path rebase-apply) 2>/dev/null"
}
     #+end_src

**** WIP commit
     #+NAME: git-WIP
     #+begin_src shell :noweb yes :exports code
git-WIP () {
    git add --all
    git commit -m "WIP"
}
     #+end_src


*** Jokes
    #+NAME: jokes
    #+begin_src shell :noweb yes :exports code
<<hitchhikersGuideToTheGalaxy>>
    #+end_src

**** The Hitchhiker's Guide to the Galaxy

    #+NAME: hitchhikersGuideToTheGalaxy
    #+begin_src shell :noweb yes :exports code
hitchhikersGuideToTheGalaxy() {
    return 42
}
    #+end_src
** Tangling all these scripts
*** Actual tangling
 #+NAME: tangle_scripts
 #+begin_src shell :shebang #!/bin/bash :noweb yes :results output
tangle_scripts () {
    emacs --batch -l org --eval '(org-babel-tangle-file "~/dotfiles/scripts/scripts.org")'
    <<createChecksumFile>>
}
 #+end_src



*** Scripts checksum
    #+NAME: createChecksumFile
    #+begin_src shell :noweb yes :exports code
echo $(sha512sum ~/dotfiles/scripts/scripts.org) > ~/dotfiles/bash/.bashrc.d/scripts_checksum
    #+end_src

** Devices
*** MTP
*** Kindle
    #+NAME: Kindle
    #+begin_src shell :noweb yes :exports code
<<unmountKindle>>
    #+end_src
**** Unmount
    #+NAME: unmountKindle
    #+begin_src shell :noweb yes :exports code
/bin/umount -l /media/kindle
    #+end_src

**** Get highlights
     #+NAME: zitat_kindle
     #+begin_src shell :noweb yes :exports code
~/zitat/zitat.py /media/kindle/documents/My Clippings.txt ~/my_clippings/clippings.org
     #+end_src

** Docker
   #+NAME: Docker
   #+begin_src shell :noweb yes :exports code
<<amIinDocker>>
<<enter_docker>>
<<executeInDocker>>
   #+end_src

*** Entering docker

 #+NAME: enter_docker
 #+begin_src shell :noweb yes :exports code
switch_to_docker () {
    amIinDocker >/dev/null
    rc=$?
    if [[ $rc != 0 ]]; then
        CURRENTDIR=$( pwd )
        build_dockerimage
        MY_UID=$UID docker-compose -f ~/docker-services/dev/docker-compose.yml up -d
        docker-compose -f ~/docker-services/dev/docker-compose.yml exec dev_rhel7 bash -c "cd ${CURRENTDIR} && bash"
    else
        echo "You are already in Docker, genius"
        return 0
    fi
}

build_dockerimage () {
    docker image build ~/docker-services/base_dev/ -t service:base_dev --build-arg "USER=$USER" --build-arg "UID=$UID"
}
 #+end_src

*** Executing in Docker something
    #+NAME: executeInDocker
    #+begin_src shell :noweb yes :exports code
executeInDocker () {
    CURRENTDIR=$( pwd )
    docker-compose -f ~/docker-services/dev/docker-compose.yml exec dev_rhel7 bash -c "cd ${CURRENTDIR} && $1"
}
    #+end_src

*** Checking if I am in Docker
 #+NAME: amIinDocker
 #+begin_src shell :noweb yes :exports code
amIinDocker(){
    if isGCCgood && isOSgood; then
        echo "You are in Docker"
        return 0
    else
        echo "You are not in Docker"
        return 1
    fi
}
<<isOSgood>>
<<isGCCgood>>
 #+end_src

 #+NAME: isGCCgood
 #+begin_src shell :noweb yes :exports code
isGCCgood(){
    GCC_IN_DOCKER='gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'

    if [ "$(gcc --version)" == "${GCC_IN_DOCKER}" ]; then
        return 0
    else
        return 1
    fi
}
 #+end_src


 #+NAME: isOSgood
 #+begin_src shell :noweb yes :exports code
isOSgood(){
    REDHAT_RELEASE_IN_DOCKER='CentOS Linux release 7.7.1908 (Core)'

    if [ "$(cat /etc/redhat-release)" == "${REDHAT_RELEASE_IN_DOCKER}" ]; then
        return 0
    else
        return 1
    fi
}
 #+end_src
** Language
   #+NAME: language
   #+begin_src shell :noweb yes :exports code
<<Chinese>>
   #+end_src

*** Chinese
    #+NAME: Chinese
    #+begin_src shell :noweb yes :exports code
<<switch_to_traditional>>
<<switch_to_simplified>>
    #+end_src

**** Switch to traditional
     #+NAME: switch_to_traditional
     #+begin_src shell :noweb yes :exports code
switch_to_traditional () {
    dconf write /desktop/ibus/engine/pinyin/InitSimplifiedChinese false; ibus restart
}
     #+end_src

**** Switch to simplified
 #+NAME: switch_to_simplified
     #+begin_src shell :noweb yes :exports code
switch_to_simplified () {
    dconf write /desktop/ibus/engine/pinyin/InitSimplifiedChinese true; ibus restart
}
     #+end_src
** Pending classification
* Aliases
** Pending classification

* Variables
** Pending classification

* Path
** Pending classification

* Prompt
** Pending classification
